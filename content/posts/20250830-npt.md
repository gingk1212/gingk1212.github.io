+++
title = 'AMD-V の Nested Paging について'
date = 2025-08-30T18:00:00+09:00
slug = 'db5bf8ac192d71a3dc1ab7e33ec0749f'
tags = ['hypervisor']
draft = true
+++
AMD-V における Nested Paging について、有効化方法や具体的な設定方法をメモ。なお、ここで記載する内容は AMD64 Architecture Programmer’s Manual, Volume 2 (以下、APM, Vol.2) の「15.25 Nested Paging」にすべて書いてあるので詳細はそちらを参照すること。

さっそく Nested Paging についての説明をドキュメントより引用。

> The optional SVM nested paging feature provides for two levels of address translation, thus eliminating the need for the VMM to maintain shadow page tables.

CPU によるこういう支援機能があるよという話で、これを使わないと VMM 側で「ゲスト物理アドレス → ホスト物理アドレス」の変換をエミュレーションする必要性が出てくる。なお、Nested Paging は Intel VT-x でいうところの EPT (Extended Page Table) にあたるもの。

こちらが Nested Paging を有効化した際のアドレス変換の様子 (APM, Vol.2, 15.25.1 Traditional Paging versus Nested Paging より引用)。

![20250830-npt-01.png](../image/20250830-npt-01.png)

つまり、ゲストの仮想アドレスは以下の2段階を経てホストの物理アドレスに変換される。そして、この変換結果は TLB にキャッシュされる。

1. ゲストの仮想アドレス → (Guest page tables (gPT)) → ゲストの物理アドレス
1. ゲストの物理アドレス → (Nested page tables (nPT)) → ホストの物理アドレス

Nested Paging を有効にした場合、gPT のベースアドレスが格納される gCR3 やその他ページングに関わるゲスト用のレジスタとして本物の CPU のレジスタが使われるわけではなく複製されたものが使用される。そして、VMRUN 実行時に VMCB の各領域 (CR0, CR3, CR4, EFER and G_PAT) から複製された各レジスタに値がロードされる。nPT のベースアドレスが格納される nCR3 レジスタについては、ドキュメント (というか英語) 読解能力が足りてなくて確かではないがおそらく本物の CPU の CR3 レジスタが使用される (まあ CPU がよしなにやってくれている部分なのでどっちでもいい)。そして VMRUN 実行時にもともと CR3 に格納されていた値は host state-save area に退避され、これまた VMCB の N_CR3 フィールドからロードされる。

では、具体的な設定方法などについて。Nested Paging を有効化するには VMCB の NP_ENABLE フィールドを 1 にセットする必要がある。そのうえで、VMCB の N_CR3 フィールドに「ゲスト物理アドレス → ホスト物理アドレス」変換をするためのページテーブル nPT のベースアドレスをセットする。その際、このページテーブルは誰も用意してくれないので VMM 側で用意する必要がある。雑ーーな疑似コードを書くとこんなイメージ。

```c
uint64_t *npt = create_nested_page_table();
vmcb->np_enalbe = 1;
vmcb->n_cr3 = (uintptr_t)npt
...
vmrun();
```
